{"pageProps":{"allPosts":[{"slug":"useimperativehandle","data":{"title":"useImperativeHandle with TypeScript","excerpt":"The useImperativeHandle is one of the React Hooks API and is used to call methods of child components from the parent component.","image":"","isFeatured":false,"date":"2021-08-15","tags":["React","TypeScript"]},"content":"\nThe useImperativeHandle is one of the React Hooks API and is used to call methods of child components from the parent component.\nAs mentioned in the reference, imperative code using refs should be avoided in most cases.\n\n- React: v17.0.2\n- TypeScript: v4.3.5\n\n## Child component\n\n```tsx:code-editor.tsx\nimport { useImperativeHandle, forwardRef, useState } from 'react';\n\ninterface CodeEditorProps {\n  initialValue: string;\n  onChange: (value: string | undefined) => void;\n}\n\nexport interface CodeEditorHandles {\n  format: () => void;\n  fontIncrease: () => void;\n  fontDecrease: () => void;\n}\n\nconst CodeEditor = forwardRef(\n  (\n    { onChange, initialValue }: CodeEditorProps,\n    ref: React.Ref<CodeEditorHandles>\n  ) => {\n    const [fontSize, setFontSize] = useState(16);\n\n    useImperativeHandle(ref, () => ({\n      format: () => formatHandler(),\n      fontIncrease: () => setFontSize((prev) => prev + 1),\n      fontDecrease: () => setFontSize((prev) => prev - 1),\n    }));\n\n    return (\n      ...\n    );\n  }\n);\n```\n\n## Parent component\n\n```tsx:parent.tsx\nimport { useRef } from 'react';\nimport CodeEditor, { CodeEditorHandles } from './code-editor';\n\nconst Parent = () => {\n  const ref = useRef<CodeEditorHandles>();\n\n  ...\n\n  return (\n    <div>\n      <button onClick={() => ref.current.fontIncrease()}>Plus</button>\n      <button onClick={() => ref.current.fontDecrease()}>Minus</button>\n      <button onClick={() => ref.current.format()}>Format</button>\n      <CodeEditor\n        ref={ref}\n        initialValue={initialCode}\n        onChange={changeHandler}\n      />\n    </div>\n  );\n};\n```\n"},{"slug":"github-actions","data":{"title":"Deploy a Next.js app to GitHub Pages with GitHub Actions","excerpt":"This article is how to deploy a static Next.js app to GitHub Pages with GitHub Actions. The Next.js app is a private repository, so I use a repository_dispatch event for deployment.","image":"","isFeatured":true,"date":"2021-07-28","tags":["Next.js","GitHub"]},"content":"\nThis article is how to deploy a static Next.js app to GitHub Pages with GitHub Actions. The Next.js app is a private repository, so I use a `repository_dispatch` event for deployment.\n\n## Create public repository for GitHub Pages\n\nCreate `<username>.github.io` as a public repository.\n\n## Create a personal access token\n\nSelect the `repo` scopes and generate a token, create a repository secret named `MY_GITHUB_TOKEN` for each repository and set the generated token to value.\n\n## Create a workflow of dispatch trigger (in private repository)\n\nCreate `.github/workflows/dispatch.yml`. A push event to a private repository triggers an action in the public repository.\n\n```yml:dispatch.yml\nname: 'Dispatch trigger'\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  dispatch-trigger:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Dispatch trigger\n        uses: peter-evans/repository-dispatch@v1\n        with:\n          repository: <username>/<username>.github.io\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n          event-type: sync\n```\n\n## Create a workflow of build and deployment (in public repository)\n\nCreate `.github/workflows/gh-pages.yml`. An action from the private repository executes build (`next build && next export`) and deployment jobs.\n\n```yml:gh-pages.yml\nname: GitHub Pages\n\non:\n  repository_dispatch:\n    types: [sync]\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    env:\n      FROM_REPO_USER: <username>\n      FROM_REPO_NAME: <private-repository-name>\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          repository: ${{ env.FROM_REPO_USER }}/${{ env.FROM_REPO_NAME }}\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n          ref: main\n          path: ./From\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install\n        working-directory: ./From\n        run: npm install\n      - name: Build\n        working-directory: ./From\n        run: |\n          npm run build\n          touch out/.nojekyll\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./From/out\n```\n"},{"slug":"ssg-ssr","data":{"title":"When to Use Static Generation v.s. Server-side Rendering","excerpt":"","image":"","isFeatured":false,"date":"2020-01-04","tags":["Next.js","Sample"]},"content":"\nWe recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.\n\nYou can use Static Generation for many types of pages, including:\n\n- Marketing pages\n- Blog posts\n- E-commerce product listings\n- Help and documentation\n\nYou should ask yourself: \"Can I pre-render this page **ahead** of a user's request?\" If the answer is yes, then you should choose Static Generation.\n\nOn the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.\n\nIn that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.\n"},{"slug":"mastering-javascript","data":{"title":"Mastering JavaScript","excerpt":"JavaScript is the most important programming language for web development. You probably don't know it well enough!","image":"mastering-javascript/mastering-js-thumb.png","isFeatured":false,"date":"2020-01-03","tags":["JavaScript","Sample"]},"content":"\nJavaScript powers the web - it's **the** most important programming language you need to know as a web developer.\n\nFor example, you should understand code like this:\n\n```js:example.js\nconst basics = 'Okay, that should not be too difficult actually';\n\nfunction printBasics() {\n  console.log(basics):\n}\n\nprintBasics();\n```\n\nLearn more about it [here](https://academind.com).\n"},{"slug":"getting-started-with-nextjs","data":{"title":"Getting Started with NextJS","excerpt":"NextJS is a the React framework for production - it makes building fullstack React apps and sites a breeze and ships with built-in SSR.","image":"getting-started-with-nextjs/getting-started-nextjs.png","isFeatured":true,"date":"2020-01-02","tags":["Next.js","Sample"]},"content":"\nNextJS is a **framework for ReactJS**.\n\nWait a second ... a \"framework\" for React? Isn't React itself already a framework for JavaScript?\n\nWell ... first of all, React is a \"library\" for JavaScript. That seems to be important for some people.\n\nNot for me, but still, there is a valid point: React already is a framework / library for JavaScript. So it's already an extra layer on top of JS.\n\n## Why would we then need NextJS?\n\nBecause NextJS makes building React apps easier - especially React apps that should have server-side rendering (though it does way more than just take care of that).\n\nIn this article, we'll dive into the core concepts and features NextJS has to offer:\n\n- File-based Routing\n- Built-in Page Pre-rendering\n- Rich Data Fetching Capabilities\n- Image Optimization\n- Much More\n\n## File-based Routing\n\n![Create routes via your file + folder structure](getting-started-with-nextjs/nextjs-file-based-routing.png)\n\n... More content ...\n\n### level3\n\nyyyyss\n"},{"slug":"pre-rendering","data":{"title":"Two Forms of Pre-rendering","excerpt":"","image":"","isFeatured":false,"date":"2020-01-01","tags":["Next.js","Sample"]},"content":"\nNext.js has two forms of pre-rendering: **Static Generation** and **Server-side Rendering**. The difference is in **when** it generates the HTML for a page.\n\n- **Static Generation** is the pre-rendering method that generates the HTML at **build time**. The pre-rendered HTML is then _reused_ on each request.\n- **Server-side Rendering** is the pre-rendering method that generates the HTML on **each request**.\n\nImportantly, Next.js lets you **choose** which pre-rendering form to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.\n"}],"pagePosts":[{"slug":"pre-rendering","data":{"title":"Two Forms of Pre-rendering","excerpt":"","image":"","isFeatured":false,"date":"2020-01-01","tags":["Next.js","Sample"]},"content":"\nNext.js has two forms of pre-rendering: **Static Generation** and **Server-side Rendering**. The difference is in **when** it generates the HTML for a page.\n\n- **Static Generation** is the pre-rendering method that generates the HTML at **build time**. The pre-rendered HTML is then _reused_ on each request.\n- **Server-side Rendering** is the pre-rendering method that generates the HTML on **each request**.\n\nImportantly, Next.js lets you **choose** which pre-rendering form to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.\n"}],"allTags":{"GitHub":1,"JavaScript":1,"Next.js":4,"React":1,"Sample":4,"TypeScript":1},"pageNum":2},"__N_SSG":true}