{"pageProps":{"recentPosts":[{"slug":"useimperativehandle","data":{"title":"useImperativeHandle with TypeScript","excerpt":"The useImperativeHandle is one of the React Hooks API and is used to call methods of child components from the parent component.","image":"","isFeatured":false,"date":"2021-08-15","tags":["React","TypeScript"]},"content":"\nThe useImperativeHandle is one of the React Hooks API and is used to call methods of child components from the parent component.\nAs mentioned in the reference, imperative code using refs should be avoided in most cases.\n\n- React: v17.0.2\n- TypeScript: v4.3.5\n\n## Child component\n\n```tsx:code-editor.tsx\nimport { useImperativeHandle, forwardRef, useState } from 'react';\n\ninterface CodeEditorProps {\n  initialValue: string;\n  onChange: (value: string | undefined) => void;\n}\n\nexport interface CodeEditorHandles {\n  format: () => void;\n  fontIncrease: () => void;\n  fontDecrease: () => void;\n}\n\nconst CodeEditor = forwardRef(\n  (\n    { onChange, initialValue }: CodeEditorProps,\n    ref: React.Ref<CodeEditorHandles>\n  ) => {\n    const [fontSize, setFontSize] = useState(16);\n\n    useImperativeHandle(ref, () => ({\n      format: () => formatHandler(),\n      fontIncrease: () => setFontSize((prev) => prev + 1),\n      fontDecrease: () => setFontSize((prev) => prev - 1),\n    }));\n\n    return (\n      ...\n    );\n  }\n);\n```\n\n## Parent component\n\n```tsx:parent.tsx\nimport { useRef } from 'react';\nimport CodeEditor, { CodeEditorHandles } from './code-editor';\n\nconst Parent = () => {\n  const ref = useRef<CodeEditorHandles>();\n\n  ...\n\n  return (\n    <div>\n      <button onClick={() => ref.current.fontIncrease()}>Plus</button>\n      <button onClick={() => ref.current.fontDecrease()}>Minus</button>\n      <button onClick={() => ref.current.format()}>Format</button>\n      <CodeEditor\n        ref={ref}\n        initialValue={initialCode}\n        onChange={changeHandler}\n      />\n    </div>\n  );\n};\n```\n"},{"slug":"github-actions","data":{"title":"Deploy a Next.js app to GitHub Pages with GitHub Actions","excerpt":"This article is how to deploy a static Next.js app to GitHub Pages with GitHub Actions. The Next.js app is a private repository, so I use a repository_dispatch event for deployment.","image":"","isFeatured":true,"date":"2021-07-28","tags":["Next.js","GitHub"]},"content":"\nThis article is how to deploy a static Next.js app to GitHub Pages with GitHub Actions. The Next.js app is a private repository, so I use a `repository_dispatch` event for deployment.\n\n## Create public repository for GitHub Pages\n\nCreate `<username>.github.io` as a public repository.\n\n## Create a personal access token\n\nSelect the `repo` scopes and generate a token, create a repository secret named `MY_GITHUB_TOKEN` for each repository and set the generated token to value.\n\n## Create a workflow of dispatch trigger (in private repository)\n\nCreate `.github/workflows/dispatch.yml`. A push event to a private repository triggers an action in the public repository.\n\n```yml:dispatch.yml\nname: 'Dispatch trigger'\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  dispatch-trigger:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Dispatch trigger\n        uses: peter-evans/repository-dispatch@v1\n        with:\n          repository: <username>/<username>.github.io\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n          event-type: sync\n```\n\n## Create a workflow of build and deployment (in public repository)\n\nCreate `.github/workflows/gh-pages.yml`. An action from the private repository executes build (`next build && next export`) and deployment jobs.\n\n```yml:gh-pages.yml\nname: GitHub Pages\n\non:\n  repository_dispatch:\n    types: [sync]\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    env:\n      FROM_REPO_USER: <username>\n      FROM_REPO_NAME: <private-repository-name>\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          repository: ${{ env.FROM_REPO_USER }}/${{ env.FROM_REPO_NAME }}\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n          ref: main\n          path: ./From\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install\n        working-directory: ./From\n        run: npm install\n      - name: Build\n        working-directory: ./From\n        run: |\n          npm run build\n          touch out/.nojekyll\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./From/out\n```\n"},{"slug":"ssg-ssr","data":{"title":"When to Use Static Generation v.s. Server-side Rendering","excerpt":"","image":"","isFeatured":false,"date":"2020-01-04","tags":["Next.js","Sample"]},"content":"\nWe recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.\n\nYou can use Static Generation for many types of pages, including:\n\n- Marketing pages\n- Blog posts\n- E-commerce product listings\n- Help and documentation\n\nYou should ask yourself: \"Can I pre-render this page **ahead** of a user's request?\" If the answer is yes, then you should choose Static Generation.\n\nOn the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.\n\nIn that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.\n"}],"allTags":{"GitHub":1,"JavaScript":1,"Next.js":4,"React":1,"Sample":4,"TypeScript":1}},"__N_SSG":true}